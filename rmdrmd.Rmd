---
title: "Data Replication"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
library(tidyverse)
library(lme4)
library(lmerTest) #gives pvals in lmer summary
```
```{r}
df_to_matrix=function(df){ #Since I'm only using it for this dataset, didn't bother generalizing it

  names=unique(df$Focal.Letter) #extracts a list of individuals names from the column labels
  num_rows=length(names) #gets number of rows, as this is the number of nights recorded for individuals in this group
  n=1 #This counter just prevents duplicates being calculated (e.g. BA with Akim, and Akim with BA)

  #Set up or matrix:
  mat <- matrix(data=NA,nrow=num_rows, ncol=num_rows)
  diag(mat)=0
  colnames(mat) <- names
  rownames(mat) <- names
  
  #loop through names list and populate matrix:
  for (i in n:num_rows){
    for (j in (n+1):num_rows){ #counter +1 so that we don't get self-pairings (e.g. BA with BA)
      if ((n+1) <= num_rows){ #prevents this value from overshooting the actual length of the name list by 1
        if (nrow(filter(df, (Focal.Letter == names[i]) & (Social.Partner == names[j]))) != 0){ #dyads w/ SRI 0 don't appear
          SRI = filter(df, (Focal.Letter == names[i]) & (Social.Partner == names[j]))$SRI
        } else {
          SRI=0 #if row doesn't appear, means that dyad had an SRI of 0
          }
        mat[i,j]=SRI #fills in matrix index for that dyad
      }
    }
      n=n+1 #increase counter to cycle through every individual
  }
  mat[lower.tri(mat)] = t(mat)[lower.tri(mat)] #the above loop only populates top half of matrix, this makes lower half a mirror image as the edges are not directed
  return(mat)
}
```



```{r}
netPos=read.csv("NetworkPositions_Observed.csv", header = T)
edges=read.csv("SRI_edgelist.csv", header = T)
head(edges)
head(netPos)
```
```{r}
netPos
netPos$Period=as.factor(as.character(netPos$Period))
netPos$Treatment=as.factor(netPos$Treatment)
netPos
```
```{r}
und=filter(netPos, Treatment=="C")
dis=filter(netPos, Treatment=="T")
```

```{r}
strength=spread(dis[,c(1,4,7,10)], Period, strength)
colnames(strength)[3:4] <- c("P1", "P2")
strength
summary(aov(P1 ~ P2/Tub+Focal.Letter.ID:Tub, data=strength))
summary(lmer(P1 ~ P2 + (1|Tub) , data = strength))
```


```{r}

und=filter(netPos, Treatment=="C")
#summary(aov(und$strength~und$Period/ factor(und$Focal.Letter.ID)))
#summary(aov(und$betweenness~und$Period/factor(und$Focal.Letter.ID)))
#summary(aov(und$Clustering.coefficient~und$Period/factor(und$Focal.Letter.ID)))
und %>%
    spread(TubPeriod, strength)
#fcor=21.211/1.272
#fcor
#1-pf(fcor,df1=1,df2=118)

#gcor=0.2/418.1
#gcor

summary(aov(strength ~ Period/Tub+Focal.Letter.ID:Tub, data=und))
summary(lmer(strength ~ Period + (1|Tub) + (1|Focal.Letter.ID:Tub), data = und))
21.211/(2.316*1.195)
```
```{r}
summary(lmer(strength~Treatment*Period+Sex+Elytra+Number.of.observations + (1|Focal.Letter.ID) + (1|Tub), data = netPos))
#permute
```
```{r}
edges

```

```{r}
C1_1=filter(edges, (Group.ID.Populations=="C1") & (Treatment.Period == 1))
C1_1
```
```{r}


```

```{r}
df_to_matrix(C1_1)
#write.csv(mat,"C:\\Users\\lukec\\Documents\\matrix.csv", row.names = FALSE)
```






